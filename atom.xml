<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IanDai&#39;s Notes</title>
  
  <subtitle>Just Do It.</subtitle>
  <link href="http://daiyuhe.com/atom.xml" rel="self"/>
  
  <link href="http://daiyuhe.com/"/>
  <updated>2023-05-20T13:52:12.245Z</updated>
  <id>http://daiyuhe.com/</id>
  
  <author>
    <name>注意措辞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树的先序遍历、中序遍历、后序遍历、层次遍历的迭代实现以及递归实现</title>
    <link href="http://daiyuhe.com/bucket-convert-to-red-black-tree-when-8-size/"/>
    <id>http://daiyuhe.com/bucket-convert-to-red-black-tree-when-8-size/</id>
    <published>2019-10-18T09:34:56.000Z</published>
    <updated>2023-05-20T13:52:12.245Z</updated>
    
    <content type="html"><![CDATA[<p>百度了一下，感觉能说清楚的并不多，其中有一个非常多的回答是以链表和红黑树的平均查找长度来解释，但是这种解释的所有回答中都没有提到出处，始终让人不能彻底相信。通过查阅官方文档和源码之后，在这里说说我的理解。</p><span id="more"></span><p>HashMap中的注释有一段Implementation notes，大致说明了我们的问题，我们来看看。</p><blockquote><p>Tree bins (i.e., bins whose elements are all TreeNodes) are ordered primarily by hashCode, but in the case of ties, if two elements are of the same “class C implements Comparable&lt;C&gt;”, type then their compareTo method is used for ordering. (We  conservatively check generic types via reflection to validate this – see method comparableClassFor).  The added complexity of tree bins is worthwhile in providing worst-case O(log n) operations when keys either have distinct hashes or are orderable, Thus, performance degrades gracefully under accidental or malicious usages in which hashCode() methods return values that are poorly distributed, as well as those in which many keys share a hashCode, so long as they are also Comparable. (If neither of these apply, we may waste about a factor of two in time and space compared to taking no precautions. But the only known cases stem from poor user programming practices that are already so slow that this makes little difference.)</p></blockquote><p>这一段说明了为什么要使用红黑树:</p><p>红黑树的插入、删除和遍历的最坏时间复杂度都是log(n)，因此，在意外或者恶意使用导致hashCode()方法返回值的分布很糟糕，以及在那些许多key共享一个hashCode的情况下，只要Key具有可比性，性能的下降将会是”优雅”的。(如果这两种方法都不适用，与不采取预防措施相比，我们可能会浪费大约两倍的时间和空间。但目前所知的唯一案例来自于糟糕的用户编程实践，这些实践已经非常缓慢，以至于没有什么区别。)</p><p>接下来看另外一段：</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) &#x2F; factorial(k)). The first values are:</p><p>0:    0.60653066<br>1:    0.30326533<br>2:    0.07581633<br>3:    0.01263606<br>4:    0.00157952<br>5:    0.00015795<br>6:    0.00001316<br>7:    0.00000094<br>8:    0.00000006<br>more: less than 1 in ten million</p></blockquote><p>这一段解释了我们的问题：</p><p>由于TreeNodes的大小大约是常规节点的两倍，因此我们仅在容器包含足够的节点以保证使用时才使用它们（参见 TREEIFY_THRESHOLD 值）。当它们变得太小（由于移除或调整大小）时，它们会被转换回普通的bin。理想情况下，在随机哈希代码下，bin中的节点频率遵循泊松分布，下面就是list size k 的频率表。</p><p><strong>结论</strong>：<br>由频率表可以看出，桶的长度超过8的概率是非常小的，结合上一段提到的恶意使用，我想，加入红黑树的其中一个主要原因是为了防止恶意使用带来的性能骤降。作者根据概率统计而选择了8作为阀值，由此可见，将阈值定为8这个选择是非常严谨和科学的一个决定。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;百度了一下，感觉能说清楚的并不多，其中有一个非常多的回答是以链表和红黑树的平均查找长度来解释，但是这种解释的所有回答中都没有提到出处，始终让人不能彻底相信。通过查阅官方文档和源码之后，在这里说说我的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://daiyuhe.com/categories/Java/"/>
    
    
    <category term="HashMap" scheme="http://daiyuhe.com/tags/HashMap/"/>
    
    <category term="Java" scheme="http://daiyuhe.com/tags/Java/"/>
    
    <category term="源码分析" scheme="http://daiyuhe.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>为什么HashMap桶长度超过8才会转换成红黑树</title>
    <link href="http://daiyuhe.com/traversal-of-binary-tree/"/>
    <id>http://daiyuhe.com/traversal-of-binary-tree/</id>
    <published>2019-10-17T09:53:06.000Z</published>
    <updated>2023-05-20T13:54:24.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遍历二叉树的迭代实现"><a href="#遍历二叉树的迭代实现" class="headerlink" title="遍历二叉树的迭代实现"></a>遍历二叉树的迭代实现</h2><h3 id="先序遍历：根-左-右"><a href="#先序遍历：根-左-右" class="headerlink" title="先序遍历：根-左-右"></a>先序遍历：根-左-右</h3><p>实现思路：使用栈。由于栈是后进先出，所以push的顺序为右-左。</p><ol><li>首先入栈root</li><li>node &#x3D; 出栈，记录当前值</li><li>入栈node.right</li><li>入栈node.left</li><li>重复2-4，直到栈空<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        list.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span></li></ol><h3 id="中序遍历：左-根-右"><a href="#中序遍历：左-根-右" class="headerlink" title="中序遍历：左-根-右"></a>中序遍历：左-根-右</h3><p>实现思路：使用栈。当前节点有左节点时，入栈左节点。当前节点没有左节点时，记录当前值，然后入栈右节点。</p><ol><li>if root.left !&#x3D; null 转2 else 转4</li><li>入栈root.left</li><li>root &#x3D; root.left 转1</li><li>node &#x3D; 出栈，记录当前值</li><li>入栈node.right</li><li>root &#x3D; node.right</li><li>重复1-6，直到栈空以及root为null<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            root = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="后序遍历：左-右-根"><a href="#后序遍历：左-右-根" class="headerlink" title="后序遍历：左-右-根"></a>后序遍历：左-右-根</h3><p>实现思路：使用栈。我们通过根-右-左的方式将每次获取的值保存到列表的第一位，最后得到的结果就会是左-右-根。</p><ol><li>首先入栈root</li><li>node &#x3D; 出栈，记录当前值到列表第一位</li><li>入栈node.left</li><li>入栈node.right</li><li>重复2-4，直到栈空<br>我们出栈的顺序是根-右-左，由于每次记录到位置0，这样就将顺序反向形成左-右-根。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        list.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>实现思路：使用队列。由于栈的特性使用栈很难搞定层次遍历，我们借用队列的先进先出特性实现二叉树的层次遍历。</p><ol><li>入队root</li><li>node &#x3D; 出队，记录当前值</li><li>入队node.left</li><li>入队node.right</li><li>重复2-4，直到队列为空<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        list.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="遍历二叉树的递归实现"><a href="#遍历二叉树的递归实现" class="headerlink" title="遍历二叉树的递归实现"></a>遍历二叉树的递归实现</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderRecursion</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preorderRecursion(list, root.left);</span><br><span class="line">    preorderRecursion(list, root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorderRecursion</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inorderRecursion(list, root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inorderRecursion(list, root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorderRecursion</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postorderRecursion(list, root.left);</span><br><span class="line">    postorderRecursion(list, root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;遍历二叉树的迭代实现&quot;&gt;&lt;a href=&quot;#遍历二叉树的迭代实现&quot; class=&quot;headerlink&quot; title=&quot;遍历二叉树的迭代实现&quot;&gt;&lt;/a&gt;遍历二叉树的迭代实现&lt;/h2&gt;&lt;h3 id=&quot;先序遍历：根-左-右&quot;&gt;&lt;a href=&quot;#先序遍历：根-左-右&quot; class=&quot;headerlink&quot; title=&quot;先序遍历：根-左-右&quot;&gt;&lt;/a&gt;先序遍历：根-左-右&lt;/h3&gt;&lt;p&gt;实现思路：使用栈。由于栈是后进先出，所以push的顺序为右-左。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先入栈root&lt;/li&gt;
&lt;li&gt;node &amp;#x3D; 出栈，记录当前值&lt;/li&gt;
&lt;li&gt;入栈node.right&lt;/li&gt;
&lt;li&gt;入栈node.left&lt;/li&gt;
&lt;li&gt;重复2-4，直到栈空&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;title function_&quot;&gt;preorderTraversal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode root)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (root == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Stack&amp;lt;TreeNode&amp;gt; stack = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Stack&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!stack.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; stack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(node.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node.right != &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.push(node.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (node.left != &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.push(node.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; list;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://daiyuhe.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://daiyuhe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://daiyuhe.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-213-House-Robber-II</title>
    <link href="http://daiyuhe.com/leetcode-213-house-robber-ii/"/>
    <id>http://daiyuhe.com/leetcode-213-house-robber-ii/</id>
    <published>2019-09-12T07:27:42.000Z</published>
    <updated>2021-03-28T14:33:53.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle</strong>. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),</span><br><span class="line">             because they are adjacent houses.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure><p>这一题是LeetCode 198的升级版，但题198不是环形的，这里就先给出题198的解题思路。</p><p>我们使用动态规划法，数组dp保存每个位置的最优解。<br>那么，当下标为i时，dp[i]的值就应该是dp[i-1]和(dp[i-2]+nums[i])中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到我们的第213题，由于是房屋为环形的，所以第一间跟最后一间房不能同时抢，这样我们可以分为两种情况，抢第一间或者不抢第一间，这样我们就把问题拆成了计算两次非环形的抢劫问题。</p><ol><li>抢第一间。最后一间不能抢，此时相当于取值范围[0, n-2]的题198。</li><li>不抢第一间。第一间不能抢，此时相当于取值范围[1, n-1]的题198。</li></ol><p>我们只需要分别计算这两种情况，并且取最大值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)   <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>)   <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">3</span>)   <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], Math.max(nums[<span class="number">1</span>], nums[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rob the house 0</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i&lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[nums.length - <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//not rob the house 0</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(nums[<span class="number">1</span>], nums[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i&lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(max, dp[nums.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;House-Robber-II&quot;&gt;&lt;a href=&quot;#House-Robber-II&quot; class=&quot;headerlink&quot; title=&quot;House Robber II&quot;&gt;&lt;/a&gt;House Robber II&lt;/h3&gt;&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are &lt;strong&gt;arranged in a circle&lt;/strong&gt;. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and &lt;strong&gt;it will automatically contact the police if two adjacent houses were broken into on the same night&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight &lt;strong&gt;without alerting the police&lt;/strong&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://daiyuhe.com/categories/LeetCode/"/>
    
    
    <category term="算法" scheme="http://daiyuhe.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://daiyuhe.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>一次清除Linux挖矿病毒的经历(sysupdate, networkservice进程)</title>
    <link href="http://daiyuhe.com/traversal-of-binary-tree/"/>
    <id>http://daiyuhe.com/traversal-of-binary-tree/</id>
    <published>2019-09-05T09:10:06.000Z</published>
    <updated>2023-05-20T13:53:50.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>闲来无事准备用服务器搭建个环境玩玩，连上服务器之后发现命令行卡的飞起，使用top看看cpu占用率，这里上前三截图。<br><img src="/traversal-of-binary-tree/cpu.png"><br>sysupdate 系统更新？？<br>networkservice 网络服务？？？</p><p>上阿里云管理控制台看看CPU占用率，占用率直接100%，再看看CPU以及内存的记录，已经被占领两三天了，阿里云也没有告警。<br><img src="/traversal-of-binary-tree/cpu_used.png"></p><hr><span id="more"></span><h2 id="清除的过程"><a href="#清除的过程" class="headerlink" title="清除的过程"></a>清除的过程</h2><p>使用top已经知道了进程号，接下来看看位置，命令ls -l proc&#x2F;{进程号}&#x2F;exe<br><img src="/traversal-of-binary-tree/pid.png"><br>sysupdate、networkservice都在&#x2F;etc&#x2F;目录下</p><p>到etc下，除了sysupdate、networkservice 同时还有sysguard、update.sh，除了update.sh其余的都是二进制文件，应该就是挖矿的主程序以及守护程序了。</p><p>找到了源头update.sh，接下来分析下这个脚本。</p><p>。。。<br>。。。</p><p>恩。。。我们有时间再写分析过程，这里先直接给出解决方案。</p><ol><li>删除定时任务 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /var/spool/cron/root 或crontab -r</span><br></pre></td></tr></table></figure></li><li>杀掉进程 删除文件<br> 首先杀进程，kill -9 {进程号}，然后删除文件<br> 直接删除sysupdate你会发现无法删除，因为一般病毒会使用chattr +i命令，我们使用chattr -i sysupdate，然后再 rm -f sysupdate 即可正常删除。<br> 同理删除networkservice、sysguard、update.sh、config.json。</li><li>&#x2F;root&#x2F;.ssh&#x2F;authorized_keys 删除或修复</li></ol><p><strong>如果你被攻破的是root用户(或者被攻破的用户权限较大),你可能还需要</strong></p><ol><li>修复SELinux<br> 病毒脚本首先就会尝试关闭SELinux子系统，我们可以使用getenforce命令查看SELinux状态。<br> 如果你想要重新打开，可以修改&#x2F;etc&#x2F;selinux&#x2F;config文件将SELINUX&#x3D;disabled改为SELINUX&#x3D;enforcing，然后重新启动服务器。</li><li>wget命令和curl命令会被改为wge和cur，这样用着很变扭，改回来 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /bin/wge /bin/wget</span><br><span class="line"><span class="built_in">mv</span> /bin/cur /bin/curl</span><br><span class="line"><span class="built_in">mv</span> /usr/bin/wge /usr/bin/wget</span><br><span class="line"><span class="built_in">mv</span> /usr/bin/cur /usr/bin/curl</span><br></pre></td></tr></table></figure></li><li>恢复防火墙配置<br> 这里给出病毒脚本修改的iptables配置的语句，方便读者修复 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -A OUTPUT -p tcp --dport 3333 -j DROP</span><br><span class="line">iptables -A OUTPUT -p tcp --dport 5555 -j DROP</span><br><span class="line">iptables -A OUTPUT -p tcp --dport 7777 -j DROP</span><br><span class="line">iptables -A OUTPUT -p tcp --dport 9999 -j DROP</span><br><span class="line">iptables -I INPUT -s 43.245.222.57 -j DROP</span><br><span class="line">service iptables reload</span><br></pre></td></tr></table></figure> 如果你的iptables策略确定被清除并且修改了，那直接清空并重新配置即可。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;闲来无事准备用服务器搭建个环境玩玩，连上服务器之后发现命令行卡的飞起，使用top看看cpu占用率，这里上前三截图。&lt;br&gt;&lt;img src=&quot;/traversal-of-binary-tree/cpu.png&quot;&gt;&lt;br&gt;sysupdate 系统更新？？&lt;br&gt;networkservice 网络服务？？？&lt;/p&gt;
&lt;p&gt;上阿里云管理控制台看看CPU占用率，占用率直接100%，再看看CPU以及内存的记录，已经被占领两三天了，阿里云也没有告警。&lt;br&gt;&lt;img src=&quot;/traversal-of-binary-tree/cpu_used.png&quot;&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://daiyuhe.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://daiyuhe.com/tags/Linux/"/>
    
    <category term="挖矿病毒" scheme="http://daiyuhe.com/tags/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
</feed>
